#include <cpen333/process/subprocess.h>
#include <cpen333/process/shared_memory.h>
#include <cpen333/process/mutex.h>
#include <chrono>
#include <thread>
#include <string>
#include <iostream>

#define MALWARE_MEMORY_NAME "Malware_memory"
#define MALWARE_MUTEX_NAME "Malware_mutex"
#define NUMBER_OF_PROCESS 3
#define PARENT_INDEX 0

struct SharedData {

	int parent_key; //parent key so that only the parent does the action and not its children
	int parent_key2; //key used for the while loop
	int checkup_counter [NUMBER_OF_PROCESS];

};


// Usage:
//    malware <name> <index>
// name is any name
// index is 0 or 1
// defaults to name:malware, index:0
int main(int argc, char* argv[]) {

  // extract name and index
  int index = 0;
  std::string name = "malware";
  if (argc > 1) {
    name = argv[1];
  }
  if (argc > 2) {
    index = std::atoi(argv[2]);//string to int
  }

  std::cout << name << " " << std::to_string(index)  << " started" << std::endl;

  //========================================================
  // TODO: CREATE AND INITIALIZE SHARED MEMORY
  //========================================================
  cpen333::process::shared_object<SharedData> memory(MALWARE_MEMORY_NAME);
  cpen333::process::mutex mutex_(MALWARE_MUTEX_NAME);
  std::vector<cpen333::process::subprocess> processes;

  //ONLY the parent does this
  if (memory->parent_key != 604123) {
	  memory->parent_key = 604123;

	  //initialize checkup_counter to be 0;
	  for (int i = 0; i < NUMBER_OF_PROCESS; ++i)
	  {
		  memory->checkup_counter[i] = 0;
	  }

	  std::vector<std::string> args; //arguments/cmd for processes
	  args.push_back("./malware");
	  args.push_back("malware");
	  args.push_back(std::to_string(index+1));
	  processes.push_back(
		  cpen333::process::subprocess(args, true, true)//creates a process based on the args
	  );
  }


  int oindex = (index+1)%2;  // index of other malware process

  //=========================
  //PARENT WHILE LOOP
  //=========================
  if (memory->parent_key2 != 604123)
  {
	  memory->parent_key2 = 604123;
	  while (true) {
		 // std::cout << name << " " << std::to_string(index) << " running" << std::endl;

		  //=======================================================
		  // TODO: CHECK IF OTHER PROCESS MISSED CHECK-IN(S)
		  //       - LAUNCH IF NOT RESPONDING
		  //=======================================================

		  //check parent counter with child counters; if they dont match spawn another
		  if (memory->checkup_counter[PARENT_INDEX] != memory->checkup_counter[oindex])
		  {
			  memory->checkup_counter[PARENT_INDEX] = 0;
			  memory->checkup_counter[oindex] = 0;
			  std::cout << memory->checkup_counter[PARENT_INDEX] << std::endl;
			  std::vector<std::string> args; //arguments/cmd for processes
			  args.push_back("./malware");
			  args.push_back("malware");
			  args.push_back(std::to_string(oindex));
			  processes.push_back(
				  cpen333::process::subprocess(args, true, true)
			  );
		  }
			
		  std::unique_lock<decltype(mutex_)> parent_lock(mutex_);
		  memory->checkup_counter[PARENT_INDEX]++;
		  std::cout << memory->checkup_counter[PARENT_INDEX] << std::endl;
		  parent_lock.unlock();
		  std::this_thread::sleep_for(std::chrono::seconds(7));
	  }
	  
  }
  

  //=========================
  //CHILD WHILE LOOP
  //=========================
  while (true)
  {
	  std::unique_lock<decltype(mutex_)> lock(mutex_);
	  memory->checkup_counter[index]++;
	  std::cout << memory->checkup_counter[index] << std::endl;
	  lock.unlock();
	  std::this_thread::sleep_for(std::chrono::seconds(7));
  }


  return 0;
}